## **1️⃣ General Guidelines**
- Keep APIs RESTful with clean, predictable endpoint structures.
- Use JWT authentication for secured access to all endpoints.
- Follow Role-Based Access Control (RBAC) to manage permissions.
- Version APIs using `/api/v1/...` for backward compatibility.
- Rate-limit requests to prevent abuse.
- All API responses should follow:
  ```json
  {
    "success": true/false,
    "message": "Description",
    "data": {...}
  }
  ```

## **Environment Setup**
**IMPORTANT**: Development Environment Rules
1. Always use `.env.development` for development:
   ```bash
   # Wrong ❌
   Using .env directly
   
   # Correct ✅
   cp .env.development .env
   npm run dev
   ```
2. Clean up after development:
   ```bash
   rm .env  # Remove temporary .env
   ```
3. Never edit `.env` directly - always modify `.env.development`
4. Keep `.env.development` up to date with all required variables 

# Backend Development Guidelines

## IMPORTANT: Use Next.js Route Handlers ONLY

We exclusively use Next.js Route Handlers for all API endpoints. Express is NOT used in this project.

## API Implementation

1. Route Handler Structure:
```typescript
// src/app/api/[route]/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const data = await prisma.model.findMany();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch data' },
      { status: 500 }
    );
  }
}
```

2. Dynamic Routes:
```typescript
// src/app/api/[route]/[id]/route.ts
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  // Handle dynamic route
}
```

3. Query Parameters:
```typescript
const { searchParams } = new URL(request.url);
const param = searchParams.get('paramName');
```

4. Request Body:
```typescript
const data = await request.json();
```

## Authentication

1. Use NextAuth.js for all authentication
2. Always check session in route handlers
3. Use middleware for protected routes
4. Never store sensitive data in client-side code

## Error Handling

1. Use structured error responses:
```typescript
return NextResponse.json(
  { error: 'Error message' },
  { status: statusCode }
);
```

2. Log errors properly:
```typescript
console.error('Error context:', error);
```

3. Use appropriate status codes:
- 200: Success
- 201: Created
- 400: Bad Request
- 401: Unauthorized
- 403: Forbidden
- 404: Not Found
- 500: Internal Server Error

## Database Access

1. Use Prisma client from `@/lib/prisma`
2. Implement service layer for complex queries
3. Use transactions for related operations
4. Handle database errors gracefully

## Security

1. Validate all inputs
2. Use CORS appropriately
3. Implement rate limiting
4. Set security headers
5. Never expose sensitive data

## Performance

1. Optimize database queries
2. Implement caching where appropriate
3. Use proper indexing
4. Handle concurrent requests properly

## Testing

1. Write unit tests for utilities
2. Test API endpoints
3. Mock external services
4. Test error scenarios

## Migration from Express

If you find Express code:
1. Convert to Next.js Route Handlers
2. Use NextResponse instead of res.json()
3. Use NextAuth.js for authentication
4. Remove Express middleware
5. Delete Express server files 