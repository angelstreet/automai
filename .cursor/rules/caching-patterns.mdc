# Next.js Caching Strategy Cursor Rules

This document outlines the standard caching rules for our Next.js application, ensuring efficient performance and minimizing redundant database calls through a hybrid server-side and client-side caching approach.

## Core Principles

1. **Layered Caching**: Implement caching for READ operations at the Server Actions Layer on the server and extend caching to the Client Layer for dynamic client-side interactions.
2. **Server-Side Efficiency**: Utilize Next.js’s built-in caching tools for server-side READ operations, paired with explicit invalidation methods to keep data fresh.
3. **Client-Side Deduplication**: Employ a client-side caching library to prevent duplicate data fetches and manage state, integrated with server-side pre-fetched data.
4. **Data Consistency**: Ensure cache invalidation is synchronized across server and client layers after WRITE operations to maintain up-to-date data.
5. **No Database Caching**: Keep the Database Layer free of any caching logic to provide raw, uncached data access.

## Three-Tier Architecture

### 1. Database Layer (Located in /lib/supabase/db-*)

- **Purpose**: Handles direct database operations without any caching or business logic.
- **Rules**:
  - Accepts a cookieStore parameter or equivalent for authentication purposes.
  - Executes raw database queries using the Supabase client.
  - Never implements caching at this layer.
  - Never calls other functions within the Database Layer to avoid nesting.

### 2. Server Actions Layer (Located in /app/actions/*.ts)

- **Purpose**: Manages server-side caching for READ operations and processes WRITE operations, serving both Server Components and client-side API requests.
- **Rules**:
  - All functions must be marked with the 'use server' directive to ensure server-only execution.
  - Wrap READ operations with Next.js’s cache function, using explicit keys like resource identifiers (e.g., user ID).
  - Retrieve cookies using the cookies function from next/headers for authentication.
  - Call Database Layer functions, passing the cookieStore for authenticated queries.
  - Never cache WRITE operations such as create, update, or delete actions.
  - Invalidate caches after WRITE operations using revalidateTag (preferred) or revalidatePath to ensure stale data is refreshed.

### 3. Client-Side Layer (Located in /app/[locale]/[tenant]/*/components/*.tsx)

- **Purpose**: Manages user interface and dynamic data fetching with client-side caching to prevent redundant requests.
- **Rules**:
  - All components must be marked with the 'use client' directive to indicate client-side execution.
  - Use a client-side caching library’s query hook for READ operations, importing functions from the Server Actions Layer.
  - Use a mutation hook for WRITE operations, invalidating specific cached queries afterward to refresh data.
  - Integrate with Server Components by accepting pre-fetched data or hydrated state.
  - Limit use of useEffect to side effects not managed by the caching library, including cleanup to prevent memory leaks.
  - Never call Database Layer functions directly from client components.

## Server Components (Located in /app/[locale]/[tenant]/*/page.tsx)

- **Purpose**: Pre-fetches data for server-side rendering, providing initial data to client-side components.
- **Rules**:
  - Call Server Actions directly to fetch data.
  - Pass pre-fetched data to Client Components through props.
  - Use the client-side caching library’s dehydration method to prepare data for client-side hydration when needed.

## Global Configuration

### Client-Side Caching Setup
- Configure a client-side caching library provider in the application’s root file (e.g., /app/_app.tsx).
- Set default caching options, such as a 5-minute stale time (data freshness threshold) and a 10-minute cache time (data retention period), to balance performance and freshness.

## Anti-Patterns to Avoid

- Do not implement caching in the Database Layer.
- Do not call Database Layer functions directly from Client Components.
- Do not cache WRITE operations like create, update, or delete.
- Do not omit cache invalidation (revalidateTag or invalidateQueries) after WRITE operations.
- Do not use excessive dependencies in useEffect hooks that trigger unnecessary refetching.
- Do not perform database queries directly in render functions.

## Debugging Caching Problems

If redundant database queries occur:
1. Confirm that Server Actions use the cache function for READ operations.
2. Verify that revalidateTag or revalidatePath is called after WRITE operations.
3. Ensure client-side query keys are unique and consistent across components.
4. Check that useEffect dependencies in Client Components are minimal and appropriate.
5. Use React Developer Tools and Next.js logs to inspect render cycles and cache behavior.