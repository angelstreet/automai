# Next.js Caching Patterns

This document defines the standard caching patterns for server actions in our Next.js application to ensure consistent performance and minimize redundant database calls.

## Three-Tier Architecture Caching Strategy

Our application follows a strict three-tier architecture with caching implemented at the Server Action layer:

### 1. Database Layer (`/lib/supabase/db-*/`)
- ✅ Accepts `cookieStore` parameter for authentication
- ✅ Performs direct database operations
- ❌ NEVER implements caching at this layer
- ❌ NEVER calls other database layer functions

```typescript
// CORRECT DATABASE LAYER IMPLEMENTATION (NO CACHING HERE)
// src/lib/supabase/db-teams/teams.ts
export async function getTeamsByUser(profileId: string, cookieStore?: any) {
  try {
    const supabase = await createClient(cookieStore);
    const { data, error } = await supabase
      .from('teams')
      .select('*')
      .eq('profile_id', profileId);
    
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

### 2. Server Actions Layer (`/app/actions/*.ts` or `/app/[locale]/[tenant]/*/actions.ts`)
- ✅ ALWAYS marked with `'use server'` directive
- ✅ ALWAYS wraps READ operations with React's `cache()` function
- ✅ ALWAYS includes explicit cache key parameters
- ✅ ALWAYS calls `cookies()` from 'next/headers' to get cookie store
- ✅ ALWAYS passes cookie store to database functions
- ❌ NEVER caches WRITE operations (create, update, delete)
- ✅ ALWAYS uses `revalidatePath()` after WRITE operations

```typescript
// CORRECT SERVER ACTION IMPLEMENTATION WITH CACHING
// src/app/[locale]/[tenant]/team/actions.ts
'use server';

import { cache } from 'react';
import { cookies } from 'next/headers';
import { revalidatePath } from 'next/cache';
import { getTeamsByUser } from '@/lib/supabase/db-teams';

// CORRECT: READ operation with cache()
export const getTeams = cache(async (tenantId: string) => {
  try {
    const cookieStore = cookies();
    const result = await getTeamsByUser(tenantId, cookieStore);
    return result;
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// CORRECT: WRITE operation without cache()
export async function createTeam(data: TeamInput) {
  try {
    const cookieStore = cookies();
    const result = await createTeamInDb(data, cookieStore);
    
    // Revalidate to clear stale cache paths
    revalidatePath('/[locale]/[tenant]/team');
    return result;
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

### 3. Client Components (`/app/[locale]/[tenant]/*/components/*.tsx`)
- ✅ ALWAYS marked with `'use client'` directive
- ✅ ALWAYS imports from server actions, NEVER from database layer
- ✅ ALWAYS implements cleanup with `isMounted` flag in useEffect
- ✅ ALWAYS uses minimal dependencies in useEffect to prevent excessive refetching
- ✅ ALWAYS properly handles loading states

```typescript
// CORRECT CLIENT COMPONENT IMPLEMENTATION
// src/app/[locale]/[tenant]/team/_components/client/TeamList.tsx
'use client';

import { useState, useEffect } from 'react';
import { getTeams } from '@/app/[locale]/[tenant]/team/actions';

export function TeamList({ tenantId }) {
  const [teams, setTeams] = useState([]);
  const [loading, setLoading] = useState(true);
  
  // CORRECT: Single effect with cleanup and minimal dependencies
  useEffect(() => {
    let isMounted = true;
    
    async function fetchData() {
      try {
        setLoading(true);
        const result = await getTeams(tenantId);
        
        if (!isMounted) return;
        
        if (result.success) {
          setTeams(result.data);
        }
      } finally {
        if (isMounted) setLoading(false);
      }
    }
    
    fetchData();
    return () => { isMounted = false; };
  }, [tenantId]); // Only depend on tenantId
  
  // Render component with teams data
}
```

## Server Component Optimization

For even better performance, use Server Components to prefetch data:

```typescript
// CORRECT SERVER COMPONENT IMPLEMENTATION
// src/app/[locale]/[tenant]/team/page.tsx
import { getTeams } from './actions';
import { TeamList } from './_components/client/TeamList';

// Server component (no 'use client' directive)
export default async function TeamPage({ params }) {
  const { tenant } = params;
  const initialData = await getTeams(tenant);
  
  return <TeamList initialData={initialData} tenantId={tenant} />;
}
```

## Common Anti-patterns to Avoid

- ❌ **NEVER** implement caching at the database layer
- ❌ **NEVER** call database functions directly from client components
- ❌ **NEVER** use `useEffect` with dependencies that cause cascading fetches
- ❌ **NEVER** cache write operations (create/update/delete)
- ❌ **NEVER** forget to call `revalidatePath()` after mutations
- ❌ **NEVER** make database calls in render functions
- ❌ **NEVER** use unnecessary dependencies in useEffect hooks

## Debugging Caching Issues

If you're seeing repeated database queries:

1. Verify server actions use React's `cache()` function for read operations
2. Check that `revalidatePath()` is called after write operations
3. Ensure client components have proper dependency arrays in useEffect
4. Implement cleanup with isMounted flag in client components
5. Use React DevTools to analyze render cycles 