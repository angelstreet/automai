---
description: Authentication Implementation
globs: src/middleware.ts, src/lib/supabase-auth.ts, src/utils/supabase/*, src/app/[locale]/(auth)/**/*.tsx
alwaysApply: true
---

# Authentication Implementation Rules

## Authentication Architecture

The application uses Supabase for authentication and supports multiple providers:
- OAuth providers (Google, GitHub)
- Email/password (native Supabase)
- Magic link authentication

## Supabase Authentication Configuration

### Core Setup in src/lib/supabase-auth.ts

```typescript
import { createClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';

// Create a Supabase client for authentication
const supabaseAuth = createClient(
  env.NEXT_PUBLIC_SUPABASE_URL,
  env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
    },
  }
);

export default supabaseAuth;
```

### Server-Side Authentication in utils/supabase/server.ts

```typescript
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { env } from '@/lib/env';

export function createServerSupabaseClient() {
  const cookieStore = cookies();
  
  return createServerClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        get(name) {
          return cookieStore.get(name)?.value;
        },
        set(name, value, options) {
          cookieStore.set(name, value, options);
        },
        remove(name, options) {
          cookieStore.delete(name, options);
        },
      },
    }
  );
}
```

### ⚠️ CRITICAL AUTH RULES

1. **NEVER hardcode locales in authentication redirects**
   - ❌ `window.location.href = '/en/login'`
   - ✅ `window.location.href = '/${locale}/login'`

2. **NEVER include route groups in page URLs**
   - ❌ `window.location.href = '/(auth)/auth-redirect'`
   - ✅ `window.location.href = '/auth-redirect'`

3. **Auth file modifications require extreme caution**
   - Changes to redirect logic can break internationalization
   - Always test with all supported locales
   - Require peer review for auth changes

## Authentication Middleware

### Path-Based Authentication

1. **Precise Path Matching**: Never use loose string matching 
   ```typescript
   // ❌ INCORRECT - Too loose
   const isProtectedRoute = request.nextUrl.pathname.includes('/dashboard');
   
   // ✅ CORRECT - Parse path parts for exact matching
   const pathParts = request.nextUrl.pathname.split('/').filter(Boolean);
   const isProtectedRoute = pathParts.some(part => part === 'dashboard');
   ```

2. **Middleware is the Single Auth Authority**
   ```typescript
   // ✅ CORRECT - Server middleware handles unauthenticated users
   if (!session && isProtectedRoute) {
     return NextResponse.redirect(loginUrl);
   }
   ```

3. **Proper Path Structure With i18n**
   ```typescript
   // ✅ CORRECT - Handle i18n paths properly
   const pathParts = request.nextUrl.pathname.split('/').filter(Boolean);
   const locale = pathParts[0];
   const validLocale = locales.includes(locale) ? locale : defaultLocale;
   ```

4. **Comprehensive Logging**
   ```typescript
   // ✅ CORRECT - Log auth decisions 
   logger.info('Auth session check:', { 
     path: request.nextUrl.pathname, 
     hasSession: !!session,
     isProtectedRoute
   });
   ```

5. **Clear Redirect Logic**
   ```typescript
   // ✅ CORRECT - Include callbackUrl for post-login redirect
   const loginUrl = new URL(`/${validLocale}/login`, request.url);
   loginUrl.searchParams.set('callbackUrl', request.nextUrl.pathname);
   return NextResponse.redirect(loginUrl);
   ```

### Middleware Implementation Pattern

```typescript
export default async function middleware(request: NextRequest) {
  // Log middleware processing
  logger.info('Middleware processing:', request.nextUrl.pathname);
  
  // Get cookies from request
  const cookieStore = requestCookies(request);
  
  // Extract path parts for accurate matching
  const pathParts = request.nextUrl.pathname.split('/').filter(Boolean);
  
  // Define protected paths
  const protectedPaths = ['dashboard', 'admin', 'repositories', 'settings'];
  
  // Public paths that should bypass auth checks
  const publicPaths = ['login', 'signup', 'forgot-password', 'reset-password'];
  
  // Check if current path is public
  const isPublicPath = publicPaths.some(publicPath => 
    pathParts.some(part => part === publicPath)
  );
  
  // If it's a public path, allow access without auth check
  if (isPublicPath) {
    logger.info('Public path detected, bypassing auth:', request.nextUrl.pathname);
    return NextResponse.next();
  }
  
  // Check if path is protected
  const isProtectedRoute = protectedPaths.some(protectedPath => 
    pathParts.some(part => part === protectedPath)
  );
  
  // Log protection check
  logger.info('Route protection check:', {
    path: request.nextUrl.pathname,
    isProtectedRoute,
    pathParts
  });
  
  if (isProtectedRoute) {
    // Create supabase client with cookies from request
    const supabase = createMiddlewareClient({ cookies: () => cookieStore });
    
    // Get session from Supabase
    const { data: { session } } = await supabase.auth.getSession();
    
    // Log session presence
    logger.info('Auth session check:', {
      hasSession: !!session,
      sessionExp: session?.expires_at,
      now: new Date().toISOString()
    });
    
    if (!session) {
      // Extract locale from URL for redirect
      const locale = pathParts[0];
      const validLocale = locales.includes(locale) ? locale : defaultLocale;
      
      // Redirect to login with the current URL as the callbackUrl
      const loginUrl = new URL(`/${validLocale}/login`, request.url);
      loginUrl.searchParams.set('callbackUrl', request.nextUrl.pathname);
      return NextResponse.redirect(loginUrl);
    }
  }
  
  return NextResponse.next();
}
```

## Client-Side Authentication

For client components, focus only on:
1. Redirecting authenticated users away from login pages
2. Handling tenant mismatches for authenticated users
3. Showing loading states during authentication checks

```typescript
// Client component auth handling with UserContext
const { user, isLoading } = useUser();

useEffect(() => {
  // Only redirect if user is authenticated and on login page
  if (!isLoading && user && pathname.includes('/login')) {
    router.replace(`/${locale}/${user.tenantName || 'trial'}/dashboard`);
  }
}, [user, isLoading, pathname, locale, router]);
```

## Authentication Flow

1. **User initiates login** via Supabase auth providers
2. **Auth provider callback** is processed by Supabase
3. **Server middleware** validates Supabase session and authorizes access
4. **Auth-redirect page** processes successful login and redirects to dashboard
5. **UserContext** manages session state across the application

## Supabase Session Structure

```typescript
// User structure in UserContext
interface User {
  id: string;
  email?: string | null;
  name?: string | null;
  image?: string | null;
  role?: string;
  tenantId?: string;
  tenantName: string | null;
}

// Supabase auth types are imported from @supabase/supabase-js
import type { Session, User as SupabaseUser } from '@supabase/supabase-js';
```

## API Authentication Pattern

When working with API routes, use this pattern to verify authentication:

```typescript
// API Route with Supabase authentication
export async function GET(request: Request) {
  try {
    // Get the Supabase session server-side
    const cookieStore = cookies();
    const supabase = createServerClient(cookieStore);
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    // Check for authentication
    if (!session?.user) {
      return NextResponse.json({ success: false, message: 'Unauthorized' }, { status: 401 });
    }
    
    // Proceed with authenticated API logic
    // ...
  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json({ success: false, message: 'Server error' }, { status: 500 });
  }
}
```

## Multi-Tenant Authentication

1. The tenant ID and name are stored in the Supabase user metadata
2. After login, users are redirected to their tenant's dashboard
3. Middleware validates tenant access 
4. API routes enforce tenant-based access control

## Debugging Auth Issues

Common auth problems and solutions:
1. **404 on Redirect**: Check for route groups in URLs, verify page exists
2. **Missing Cookies**: Ensure Supabase cookies are present
3. **Session Issues**: Add detailed logging for session validity checks
4. **Locale Issues**: Ensure auth redirects are not hardcoding locales
5. **CORS Issues**: Verify Supabase URL configuration in environment variables