---
description: Backend Best Practices
globs: src/server/**/*.{ts,js}
---

# Backend Best Practices

## Core Principles

- Keep APIs RESTful with clean, predictable endpoint structures
- Use JWT authentication for secured access to all endpoints
- Follow Role-Based Access Control (RBAC) to manage permissions
- Version APIs using `/api/v1/...` for backward compatibility
- Rate-limit requests to prevent abuse
- Implement proper error handling and logging

## API Response Format

```typescript
interface ApiResponse<T> {
  success: boolean;
  message: string;
  data?: T;
  meta?: {
    page?: number;
    limit?: number;
    total?: number;
    hasMore?: boolean;
  };
}
```

## API Route Structure

```typescript
// src/server/api/routes/project.ts
import { Router } from 'express';
import { validateRequest } from '../middleware/validate';
import { isAuthenticated, hasPermission } from '../middleware/auth';
import { ProjectSchema } from '../schemas/project';
import { rateLimit } from '../middleware/rate-limit';

const router = Router();

router.get('/',
  isAuthenticated,
  rateLimit({ max: 100, windowMs: 15 * 60 * 1000 }), // 100 requests per 15 minutes
  async (req, res, next) => {
    try {
      const { page = 1, limit = 10 } = req.query;
      // Implementation with pagination
    } catch (error) {
      next(error);
    }
  }
);

router.post('/',
  isAuthenticated,
  hasPermission('project:create'),
  validateRequest(ProjectSchema),
  async (req, res, next) => {
    try {
      // Implementation with tenant scoping
    } catch (error) {
      next(error);
    }
  }
);
```

## Test Execution Service

```typescript
// src/server/services/test-execution.ts
import { PrismaClient } from '@prisma/client';
import { ElasticSearchClient } from '../lib/elasticsearch';
import { S3Client } from '../lib/s3';

export class TestExecutionService {
  constructor(
    private prisma: PrismaClient,
    private elastic: ElasticSearchClient,
    private s3: S3Client
  ) {}

  async executeTest(testId: string, options: ExecutionOptions) {
    // Implementation with proper error handling and logging
  }

  async storeResults(executionId: string, results: TestResults) {
    // Store results in PostgreSQL and artifacts in S3
  }

  async queryLogs(executionId: string) {
    // Query logs from Elasticsearch
  }
}
```

## WebSocket Handler

```typescript
// src/server/websocket/execution-handler.ts
import { WebSocketServer } from 'ws';
import { verifyToken } from '../utils/jwt';

export class ExecutionWebSocketHandler {
  constructor(private wss: WebSocketServer) {
    this.wss.on('connection', this.handleConnection.bind(this));
  }

  private async handleConnection(ws: WebSocket, req: Request) {
    try {
      const token = this.extractToken(req);
      const user = await verifyToken(token);
      
      ws.on('message', (data) => this.handleMessage(ws, data, user));
      ws.on('error', this.handleError);
    } catch (error) {
      ws.close(1008, 'Unauthorized');
    }
  }

  private handleMessage(ws: WebSocket, data: any, user: User) {
    // Handle real-time test execution updates
  }
}
```

## Best Practices

### API Design
- Use proper HTTP methods and status codes
- Implement pagination for list endpoints
- Use query parameters for filtering and sorting
- Version APIs for backward compatibility
- Document APIs using OpenAPI/Swagger
- Implement proper rate limiting

### Multi-tenancy
- Scope all database queries by tenant
- Implement row-level security in PostgreSQL
- Use tenant-specific caching strategies
- Isolate tenant data in storage services
- Handle tenant-specific configurations

### Test Execution
- Implement proper job queuing
- Handle long-running operations
- Store execution artifacts securely
- Implement proper retry mechanisms
- Monitor execution resources
- Handle parallel executions

### Data Storage
- Use transactions for related operations
- Implement soft deletes
- Handle large dataset operations
- Implement proper backup strategies
- Monitor database performance
- Use appropriate indexing

### Security
- Implement proper CORS policies
- Validate and sanitize all inputs
- Use prepared statements
- Monitor for suspicious activities
- Implement audit logging
- Handle sensitive data properly

### Error Handling
- Use structured error responses
- Implement proper logging levels
- Monitor critical errors
- Handle edge cases properly
- Provide meaningful error messages
- Implement circuit breakers

### Performance
- Use appropriate caching strategies
- Optimize database queries
- Handle concurrent requests
- Monitor API performance
- Implement proper timeouts
- Use connection pooling

### Deployment
- Use proper CI/CD practices
- Implement blue-green deployments
- Handle database migrations
- Monitor service health
- Implement proper backups
- Use infrastructure as code

