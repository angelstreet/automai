---
description: Backend Best Practices
globs: src/app/api/**/*.{ts,js}, src/lib/**/*.{ts,js}
alwaysApply: false
---
# Backend Best Practices

## **1️⃣ General Guidelines**
- Keep APIs RESTful with clean, predictable endpoint structures.
- Use JWT authentication for secured access to all endpoints.
- Follow Role-Based Access Control (RBAC) to manage permissions.
- Version APIs using `/api/v1/...` for backward compatibility.
- Rate-limit requests to prevent abuse.
- All API responses should follow:
  ```json
  {
    "success": true/false,
    "message": "Description",
    "data": {...}
  }
  ```

---

## **2️⃣ Authentication Rules**
- OAuth (Google, GitHub) and email/password supported via NextAuth.js.
- Passwords must be hashed using bcrypt before storage.
- JWT expiration should be set to 1 hour; refresh tokens available.
- Multi-Tenancy Support: Every request must be scoped to a tenant.
- Session Middleware: Attach authenticated user details to `req.user`.
- Logout API must revoke tokens from active sessions.

---

## **3️⃣ API Design Rules**
### **Projects & Use Cases**
- `POST /api/projects` → Create new project
- `GET /api/projects/:id` → Fetch project details
- `DELETE /api/projects/:id` → Soft-delete project
- `POST /api/usecases` → Create a new test case
- `GET /api/usecases/:id` → Fetch test case details
- Ensure all API endpoints validate user ownership of resources.

### **Test Execution Rules**
- `POST /api/execute/local` → Runs the test case locally
- `POST /api/execute/cloud` → Runs the test case on cloud infrastructure
- `GET /api/executions` → Fetch test run history
- Store execution logs in Elasticsearch for debugging.
- Store test results, videos, and screenshots in Supabase Storage.
- Rate-limit execution API to prevent excessive automated calls.

---

## **4️⃣ Data Storage Rules**
- PostgreSQL (Supabase) as the primary database.
- Use Prisma ORM for structured queries and migrations.
- Store test execution logs in Elasticsearch for fast querying.
- Use Supabase Storage / AWS S3 for storing test reports & assets.
- Implement soft deletes instead of hard deletes where possible.
- Use database transactions for creating and updating related resources.

---

## **5️⃣ Security & Performance Rules**
- Implement CORS policy to allow only whitelisted origins.
- Validate all user inputs to prevent SQL injection & XSS.
- Use Redis or a caching mechanism for frequently accessed data.
- Monitor API performance metrics with Prometheus & Grafana.
- Enforce strict API rate limits (e.g., max 10 requests/sec per user).

---

## **6️⃣ Error Handling & Logging**
- Use a global error handler to return structured API responses.
- Store logs in Kibana (Elasticsearch) for debugging & analysis.
- Return appropriate HTTP status codes:
  - `200 OK` for successful requests.
  - `201 Created` for successful resource creation.
  - `400 Bad Request` for validation errors.
  - `401 Unauthorized` for authentication failures.
  - `403 Forbidden` for permission issues.
  - `500 Internal Server Error` for unexpected failures.
- Critical errors must trigger alerts to Slack/Email.

---

## **7️⃣ Deployment & CI/CD Rules**
- Use GitHub Actions for CI/CD pipelines.
- Deploy to Vercel (Frontend) & Supabase/AWS (Backend).
- Automate database migrations during deployment.
- Perform zero-downtime deployments with rolling updates.
- Enable auto-scaling in production environments.

---

## **8️⃣ Future Enhancements**
- WebSockets for real-time execution tracking.
- AI-assisted test script generation & failure analysis.
- Integration with CI/CD tools (GitHub Actions, Jenkins, CircleCI).
- Automated test scheduling & parallel execution on cloud VMs.

---

### **Conclusion**
These rules establish a structured, secure, and scalable backend to support automation script development, execution, and analysis.

---

## **9️⃣ Backend Best Practices**

### **Core Principles**

- Use TypeScript for type safety and better developer experience
- Implement proper error handling and logging
- Follow RESTful API design principles
- Use middleware for cross-cutting concerns
- Implement proper authentication and authorization
- Handle environment configuration properly
- Follow security best practices

### **API Route Structure**

```typescript
// src/app/api/projects/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { validateRequest } from '@/lib/middleware/validate';
import { ProjectSchema } from '@/lib/schemas/project';
import { getProjects, createProject } from '@/lib/services/projects';

export async function GET() {
  try {
    const session = await getServerSession();
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const projects = await getProjects();
    return NextResponse.json({ success: true, data: projects });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Failed to fetch projects' },
      { status: 500 }
    );
  }
}

export async function POST() {
  try {
    const session = await getServerSession();
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const validatedData = await validateRequest(ProjectSchema);
    const project = await createProject(validatedData);
    
    return NextResponse.json(
      { success: true, data: project },
      { status: 201 }
    );
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Failed to create project' },
      { status: 500 }
    );
  }
}
```

### **Error Handling**

```typescript
// src/lib/utils/errors.ts
export class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public isOperational = true
  ) {
    super(message);
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

// src/middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  try {
    // Middleware logic
    return NextResponse.next();
  } catch (error) {
    if (error instanceof AppError) {
      return NextResponse.json(
        { status: 'error', message: error.message },
        { status: error.statusCode }
      );
    }
    
    // Log unexpected errors
    console.error('Unexpected error:', error);
    return NextResponse.json(
      { status: 'error', message: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### **Authentication**

```typescript
// src/server/middleware/auth.ts
import { verifyToken } from '../utils/jwt';

export const isAuthenticated = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      throw new AppError(401, 'No token provided');
    }

    const decoded = await verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    next(new AppError(401, 'Invalid token'));
  }
};
```

### **Request Validation**

```typescript
// src/server/middleware/validate.ts
import { Schema } from 'zod';

export const validateRequest = (schema: Schema) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      await schema.parseAsync(req.body);
      next();
    } catch (error) {
      next(new AppError(400, 'Invalid request data'));
    }
  };
};
```

### **Environment Configuration**

```typescript
// src/server/config/env/index.ts
import { z } from 'zod';
import dotenv from 'dotenv';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']),
  PORT: z.string().transform(Number),
  DATABASE_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
});

dotenv.config({
  path: `src/server/config/env/.env.${process.env.NODE_ENV}`,
});

export const env = envSchema.parse(process.env);
```

### **Best Practices**

#### **API Design**
- Use proper HTTP methods (GET, POST, PUT, DELETE)
- Return appropriate status codes
- Version your APIs
- Use query parameters for filtering
- Implement pagination for lists
- Use proper error responses

#### **Security**
- Validate all inputs
- Sanitize database queries
- Use HTTPS in production
- Implement rate limiting
- Set security headers
- Handle CORS properly
- Store secrets securely

#### **Performance**
- Implement caching where appropriate
- Use connection pooling
- Optimize database queries
- Implement proper indexing
- Handle concurrent requests
- Use compression

#### **Testing**
- Write unit tests for utilities
- Test API endpoints
- Mock external services
- Test error scenarios
- Use proper test data
- Implement integration tests

#### **Logging**
- Use proper logging levels
- Include request context
- Log important operations
- Handle sensitive data
- Implement audit logging
- Use proper logging format

#### **Code Organization**
- Follow modular architecture
- Separate concerns properly
- Use dependency injection
- Implement service layer
- Keep controllers thin
- Use proper naming conventions

