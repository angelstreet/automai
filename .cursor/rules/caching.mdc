# Caching Best Practices

## Overview

These guidelines define caching implementation across the three-layer architecture: Server DB → Server Actions → Client Hooks.

## Key Principles

1. **Three-Layer Caching**
   - Server DB: No caching (always fresh data)
   - Server Actions: Optional server-side caching for expensive operations
   - Client Hooks: Primary caching layer using SWR + storage

2. **Cache Strategy by Layer**
   ```typescript
   // 1. Client Hooks Layer (Primary Cache)
   function useData() {
     return useSWR(key, fetcher, {
       dedupingInterval: 60000,
       revalidateOnFocus: false
     });
   }

   // 2. Server Actions Layer (Optional Cache)
   let actionCache = null;
   let cacheTimestamp = 0;
   const CACHE_TTL = 5 * 60 * 1000;

   // 3. Server DB Layer (No Cache)
   const db = { /* Direct Supabase calls */ };
   ```

## Implementation Rules

1. **✅ Client-Side Caching (Hooks Layer)**
   - Use SWR as primary cache
   - Add localStorage for persistence
   - Handle SSR safely

2. **✅ Server-Side Caching (Actions Layer)**
   - Cache expensive computations
   - Use TTL for cache invalidation
   - Clear on mutations

3. **❌ Never Cache**
   - Sensitive data
   - Without expiration
   - In Server DB layer
   - Without error handling

## Example Pattern

```typescript
// Client Hook
export function useData() {
  return useSWR('key', async () => {
    // Try localStorage
    if (typeof window !== 'undefined') {
      const cached = localStorage.getItem('key');
      if (cached) return JSON.parse(cached);
    }
    
    // Fetch from Server Action
    const { data } = await serverAction();
    
    // Update localStorage
    if (data) localStorage.setItem('key', JSON.stringify(data));
    
    return data;
  }, {
    dedupingInterval: 60000,
    revalidateOnFocus: false
  });
}
``` 