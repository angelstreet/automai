---
description: API Implementation Guidelines
globs: ["src/app/api/**/*", "src/**/api/*.{ts,tsx}"]
---

# API Implementation Rules

## Required Server Structure
```
src/
  ├── app/
  │   └── api/           # All API routes MUST be here
  │       ├── [endpoint]/
  │       │   ├── route.ts      # Next.js Route Handler
  │       │   ├── validation.ts  # Request validation
  │       │   └── schema.ts      # Data schema
  │       └── ...
  └── lib/
      ├── services/      # Business logic & data access
      │   ├── hosts.ts
      │   └── ...
      └── middleware/    # API middleware
          ├── auth.ts
          └── validate.ts
```

## Route Structure

1. **Base Path**
   ```typescript
   // ✅ Correct
   const response = await fetch('/api/auth/profile');
   
   // ❌ Incorrect
   const response = await fetch('http://localhost:5001/api/auth/profile');
   const response = await fetch('http://localhost:3000/api/auth/profile');
   ```

2. **Environment Variables**
   ```typescript
   // ✅ Correct
   const baseUrl = process.env.NEXT_PUBLIC_API_URL || '';
   const response = await fetch(`${baseUrl}/api/auth/profile`);
   
   // ❌ Incorrect
   const response = await fetch('http://localhost:' + port + '/api/auth/profile');
   ```

3. **Explicit API Naming**
   ```typescript
   // ✅ Correct - Explicit purpose in the route name
   const response = await fetch('/api/fetch-all-repositories');
   
   // ❌ Incorrect - Generic name that doesn't clearly indicate purpose
   const response = await fetch('/api/repositories/fetch-all');
   ```
   
   API routes should have explicit, descriptive names that clearly indicate their purpose.
   Prefer verbose, specific route names over generic, nested routes when the operation
   is specialized or spans multiple resource types.

## API Route Implementation

1. **Route Handler Pattern**
   ```typescript
   // src/app/api/[endpoint]/route.ts
   import { NextResponse } from 'next/server';
   
   export async function GET() {
     try {
       // Implementation
       return NextResponse.json({ 
         success: true,
         data 
       });
     } catch (error) {
       return NextResponse.json(
         { 
           success: false,
           error: 'Error message'
         },
         { status: 500 }
       );
     }
   }
   ```

2. **Authentication Check**
   ```typescript
   import { getServerSession } from 'next-auth';
   
   export async function GET() {
     const session = await getServerSession();
     if (!session) {
       return NextResponse.json({
         success: false,
         error: 'Unauthorized'
       }, { status: 401 });
     }
   }
   ```

3. **Request Validation**
   ```typescript
   // schema.ts
   import { z } from 'zod';
   export const schema = z.object({...});

   // route.ts
   const body = await request.json();
   const validatedData = schema.parse(body);
   ```

## Standard Response Format

1. **Success Response**
   ```typescript
   {
     success: true,
     message?: string,
     data?: any
   }
   ```

2. **Error Response**
   ```typescript
   {
     success: false,
     error: string,
     details?: any
   }
   ```

3. **Status Codes**
   - 200: Success
   - 201: Created
   - 400: Bad Request
   - 401: Unauthorized
   - 403: Forbidden
   - 404: Not Found
   - 500: Internal Server Error

## Service Layer Implementation

1. **Service Layer Pattern**
   ```typescript
   // src/lib/services/auth.ts
   export async function getUserProfile() {
     const response = await fetch('/api/auth/profile');
     const data = await response.json();
     if (!data.success) throw new Error(data.error);
     return data.data;
   }
   ```

2. **Error Handling**
   ```typescript
   try {
     const data = await getUserProfile();
   } catch (error) {
     console.error('Failed to fetch profile:', error);
     // Handle error appropriately
   }
   ```

## Documentation Requirements

1. **API Route Documentation**
   ```typescript
   /**
    * @api {get} /api/auth/profile Get User Profile
    * @apiDescription Fetches the current user's profile
    * @apiPermission authenticated
    * @apiSuccess {Object} user User profile data
    * @apiError {Object} error Error details
    */
   ```

2. **Type Definitions**
   ```typescript
   interface ApiResponse<T> {
     success: boolean;
     message?: string;
     error?: string;
     data?: T;
   }
   ```

## Security Guidelines

1. **Authentication**: Always use NextAuth.js for authentication
2. **Validation**: Always validate request data using Zod
3. **Error Handling**: Never expose internal errors to clients
4. **Rate Limiting**: Implement rate limiting for public endpoints
5. **CORS**: Configure CORS appropriately for your environment

## WebSocket Connections

1. **Connection Setup**
   ```typescript
   // ✅ Correct
   const ws = new WebSocket(`ws://localhost:5001/api/ws`);
   
   // ❌ Incorrect
   const ws = new WebSocket('ws://localhost:3000/api/ws');
   ```

## Database Access

1. **Prisma Client Usage**
   ```typescript
   // ✅ Correct: Single instance pattern
   const globalForPrisma = global as unknown as { prisma: PrismaClient };
   export const prisma = globalForPrisma.prisma || new PrismaClient();
   
   // ❌ Incorrect: Multiple instances
   const prisma = new PrismaClient();
   ``` 